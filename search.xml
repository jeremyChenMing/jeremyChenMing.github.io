<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[react-lifeCycle]]></title>
      <url>%2F2017%2F04%2F13%2Freact-lifeCycle%2F</url>
      <content type="text"><![CDATA[一、基础先来介绍一下生命周期的定义1) componentWillMount(){}123// Mounting 安装阶段 // 在客户端和服务器上，在初始渲染发生之前立即调用一次 如果在这个方法中调用setState，// render（）将看到更新的状态，并且只会执行一次，尽管状态改变。 12// Mounting 安装阶段// setTimeout setInterval AJAX 在此之行，强烈建议 2)componentDidMount(){}1234// Mounting 安装阶段 // 调用一次，只在客户端（不在服务器上），在初始渲染发生后立即// 子组件的componentDidMount（）方法在父组件的componentDidMount（）方法之前被调用// setTimeout setInterval AJAX 在此之行，强烈建议 3)componentWillReceiveProps(nextProps){}1234// Updating 更新阶段// 在组件接收新props时调用。初始渲染不调用此方法。// 老的props可以用this.props 新值就用nextProps查看// 在此函数中调用this.setState（）不会触发附加的渲染。 4)shouldComponentUpdate(nextProps, nextState){}1234567// Updating 更新阶段// 当正在接收新的道具或状态时，在渲染之前调用。// 此方法必须返回false or true 否则报错 true则渲染，false则不渲染！在此声明周期中可以考虑是否需要进行渲染！避免不必要的性能浪费// 如果shouldComponentUpdate返回false，那么render（）将被完全跳过，直到下一个状态改变。此外，不会调用componentWillUpdate和componentDidUpdate。// 默认返回true// 如果性能是一个瓶颈，特别是有几十个或几百个组件，请使用shouldComponentUpdate来加快您的应用程序。// return true or false 5) componentWillUpdate(nextProps, nextState){}123// Updating 更新阶段// 当正在接收新的props或state时立即调用。初始渲染不调用此方法// 您不能在此方法中使用this.setState（）。如果您需要更新state以响应prop更改，请改用componentWillReceiveProps。 6)componentDidUpdate(nextProps, nextState){}123// Updating 更新阶段// 在组件的更新刷新到DOM后立即调用。初始渲染不调用此方法。// 当组件已更新时，使用此操作作为DOM操作的机会 7)componentWillUnmount(){}123// Unmounting 卸载阶段// 在组件从DOM卸载之前立即调用。// 在此方法中执行任何必要的清理，例如使计时器无效或清除在componentDidMount中创建的任何DOM元素。clearInterval or destroy 二、生命周期的执行顺序举例：只有一个组件，里面有一个onClick事件改变一个state 刷新页面：123a、componentWillMount---&gt; // 可以更改state render()----&gt; componentDidMount // 周期结束 触发onClick事件：(前提只有事件中出发setState，其他中没有)12345678shouldComponentUpdate中 return true shouldComponentUpdate--&gt; componentWillUpdate--&gt; render()--&gt; componentDidUpdate //周期结束 shouldComponentUpdate中 return false shouldComponentUpdate //周期结束 上面只是一个很简单的例子讲述了周期的执行顺序，大家可以根据顺序去做相应的操作，当然在componentWillUpdate和componentDidUpdate这两个周期中不可以使用this.setState,需要使用此方法可以在componentWillReceiveProps中去操作。周期中可能进行的操作在上面的定义中以解释。 举例：父、子组件，父组件和上述相同，字段件只是一个纯ui组件没有任何的操作,接受父组件传来的props(父组件的click可控制props的内容)。 刷新页面：1父componentWillMount---&gt;父render()----&gt;子componentWillMount---&gt;子render()---&gt;子componentDidMount---&gt;父componentDidMount 触发onClick事件: 1234子组件shouldComponentUpdate 返回的是false 父shouldComponentUpdate--&gt;父componentWillUpdate--&gt;父render()--&gt;父componentDidUpdate子组件shouldComponentUpdate 返回的是true 父shouldComponentUpdate--&gt;父componentWillUpdate--&gt;父render()---&gt;子componentWillReceiveProps---&gt;子shouldComponentUpdate---&gt;子componentWillUpdate----&gt;子render()---&gt;子componentDidUpdate---&gt;父componentDidUpdate componentWillUnmount阶段当你的组件关闭的时候，例如跳转页面的时候，此周期执行一次。可能做的操作在上面的定义。 给出一段代码：(就是上述的子组件) 1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; Component &#125; from 'react';class Another extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; son:'子组件' &#125; &#125; componentWillMount() &#123; console.log('子组件－－Mounting－componentWillMount',this.state.son) &#125; componentDidMount() &#123; console.log('子组件－－Mounting－componentDidMount',this.state.son) &#125; componentWillReceiveProps(nextProps) &#123; console.log('子组件－－Updating-componentWillReceiveProps') &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log('子组件－－Updating-shouldComponentUpdate') return true &#125; componentWillUpdate(nextProps, nextState) &#123; console.log('子组件－－Updating-componentWillUpdate') &#125; componentDidUpdate(nextProps, nextState) &#123; console.log('子组件－－Updating-componentDidUpdate') &#125; componentWillUnmount() &#123; &#125; render() &#123; return( &lt;div&gt; 我是子组件－－我是子组件－－我是子组件&#123;this.props.name&#125; &lt;/div&gt; ) &#125;&#125;export default Another; 根据上面的代码，说一个组件实例的初始化的方法过程 11）`getInitialState` 设置初始状态值，(掉调用一次)，可使用setState方法更改状态 es6语法则在这是用： 123456789101112131415constructor(props) &#123; super(props); this.displayName='name'; this.事件名=this.事件名.bind(this);//绑定事件的this,这样初始化只绑定一次，如果在render中邦定，则只要render就邦定一次。 this.state = &#123; son:'子组件' &#125;&#125;static propTypes = &#123; value:PropTypes.string, //类型的种类object string array func number bool any&#125;static defaultProps=&#123; value:'1'&#125; 12345672)`getDefaultProps `设置初始props的值，不可以更改es6语法参照上面的 static defaultProps3）`propTypes `验证传递给组件的propses6语法上述 static propTypes 4）`displayName `用于degbug调试消息，如果不写，JSX将从变量赋值中推断出类的displayName，es6语法如上述代码片段中，例如下面 // Input (JSX):1var Nav = React.createClass(&#123; &#125;);// Output (JS):1var Nav = React.createClass(&#123;displayName: &quot;Nav&quot;, &#125;);执行的顺序就是上述代码片段的顺序！ 三、总结详细了解生命周期的特性，有助于处理数据，更好的节约性能。本人一点点小的见解，还望各位路过的大神，赏脸批评指正！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Code record]]></title>
      <url>%2F2017%2F04%2F06%2FimgFIle%2F</url>
      <content type="text"><![CDATA[description: 下面还有很多精彩的内容，请继续阅读 粉丝日志 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. David Levithan, Wide Awake翻译 123NEW: DevDocs now comes with syntax highlighting. http://devdocs.io 好的@DevDocs 1[rectangle setX: 10 y: 10 width: 20 height: 20]; 123alert('Hello World!');class Peopleinclude]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react+webpack项目常用的插件(plugins)]]></title>
      <url>%2F2017%2F04%2F06%2Fcar%2F</url>
      <content type="text"><![CDATA[一、HtmlWebpackPlugin使用：1npm install html-webpack-plugin --save-dev 解释：这个插件是简化创建生成html（h5）文件用的，如果你引入的文件带有hash值的话，这个尤为的有用，不需要手动去更改引入的文件名！ 默认生成的是index.html,基本用法为： 123456789var HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);var webpackConfig = &#123; entry: &apos;index.js&apos;, output: &#123; path: &apos;dist&apos;, filename: &apos;index_bundle.js&apos; &#125;, plugins: [new HtmlWebpackPlugin()]&#125;; js通过script的标签引入到body中！如果你使用了ExtractTextPlugin来提取css，将通过link在head中引入！ 一般配置： title: 用于生成的HTML文档的标题,也就是html，head中&lt;title&gt;ceshi&lt;/title&gt; filename: 生成的文件名，default index.html template: 模版（填写相对路径，与配置文件的相对路径，例如：’./index.html’ hash: 增加hash值，使每次生成的都是唯一的不重复的 二、ExtractTextWebpackPlugin 分离我们的样式文件，例如css,sass,less1npm install --save-dev extract-text-webpack-plugin 基本用法： 12345678910111213141516171819const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;);module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, use: ExtractTextPlugin.extract(&#123; fallback: &quot;style-loader&quot;, use: &quot;css-loader&quot; &#125;) &#125; ] &#125;, plugins: [ new ExtractTextPlugin(&quot;styles.css&quot;), //输出在根目录上，也可以这样写css/styles.css ]&#125; 其中plugins中的参数配置有：（string/object） id: 插件实例的唯一标识，默认情况下是自动生成的，不建议设置filename: 生成文件的名称，可以包含[name], [id] and [contenthash]allChunks：(bollean) 从所有附加块中提取（默认情况下，它仅从初始块中提取） rules里面的参数配置有：（loader | object) options.use :{String}/{Array}/{Object} 使用的编译loader options.fallback :{String}/{Array}/{Object} 当css没有被提取的时候,可以当作保守用 options.publicPath :可以覆盖output里的publickPath 如果想生成多个css文件的话，可以这样写: 1234567891011121314151617181920212223const ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);const extractCSS = new ExtractTextPlugin(&apos;css/[name]-one.css&apos;);const extractLESS = new ExtractTextPlugin(&apos;css/[name]-two.css&apos;);module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, use: extractCSS.extract([ &apos;css-loader&apos;, &apos;postcss-loader&apos; ]) &#125;, &#123; test: /\.less$/i, use: extractLESS.extract([ &apos;css-loader&apos;, &apos;less-loader&apos; ]) &#125;, ] &#125;, plugins: [ extractCSS, //两个实例 extractLESS ]&#125;; 三、DefinePlugin 定义变量允许我们创建可在编译时配置的全局常量，这对与需要灵活配置的项目而言非常的重要，举个例子：开发中我们需要devtool来查看redux树中stroe中的变量，但是生产环境中不需要，那么就可以这样定义： 12345const nodeEnv = process.env.NODE_ENV || &apos;development&apos;;const isPro = nodeEnv === &apos;production&apos;;new webpack.DefinePlugin(&#123; &quot;__dev__&quot;: JSON.stringify(isPro) &#125;) 那么在开发环境中dev为false，打包的时候可以在CLI中输入NODE_ENV=production 这样dev就为true; 四、ProvidePlugin 提供识别码通俗点讲就是使用一些字符代替复杂的字符，例如我想用 $ 代表 jquery, 那么就可以使用这个插件，或着我想用 ‘av’ 代表 ‘./ateon/values’ 这个路径，也可以使用这个插件。 基本用法： 12345new webpack.ProvidePlugin(&#123; $: &apos;jquery&apos;, jQuery: &apos;jquery&apos;, &apos;av&apos; : &apos;./ateon/values&apos;&#125;) 在模块中使用，import lives from &#39;av&#39; === import lives from &#39;./ateon/values&#39; 五、clean-webpack-plugin 清除你的build目录基本用法： 12345678const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)// webpack config&#123; plugins: [ new CleanWebpackPlugin(paths [, &#123;options&#125;]) ]&#125; [, {options}]为可选参数 `path` An [array] of string options 参数 1234567&#123;root: __dirname,默认根目录，也就是你的package的路径（绝对路径）verbose: true, 在控制台console日志dry: false, 默认为false，删除所有的文件， 为true时，模拟删除，并不删除文件watch: false, 默认false， 为true时删除所有的编译文件exclude: [ &apos;files&apos;, &apos;to&apos;, &apos;ignore&apos; ] &#125; 一般这一项我们都使用默认值，不去设置，只需要设置path就可以了！ 总结，常用的就是这些了，后续还会在陆续的加入。。。其他相关插件！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[记录自己的生活]]></title>
      <url>%2F2017%2F04%2F05%2Fmy-life%2F</url>
      <content type="text"><![CDATA[这是一片纪录生活的标签 Content (md partial supported) 出生地四川 生活新疆 工作山西、北京 More info: 百度翻译 百度]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F04%2F05%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
